#! perl
# Author:  Chip Camden <sterling@camdensoftware.com>
# Website: http://bitbucket.org/sterlingcamden/urlpicker
# License: Open Works License 0.9
#
# {{{ README
#
# DESCRIPTION
#
# Perl extension for rxvt-unicode (aka urxvt) to enable quick keyboard
# navigation of URLs shown in the terminal window.  The design is similar
# to the 'follow hints' feature of Vimperator
# (http://vimperator.org/vimperator).
#
# INSTALLATION
#
# See the man page for urxvtperl(3) for a full discussion of Perl
# extensions.  Enable this extension using one of the methods documented
# there.  For instance, you could place the script url-picker in
# /usr/local/lib/urxvt/perl, then add the following to .Xdefaults:
#
# URxvt.perl-ext: default,matcher,url-picker
# URxvt.keysym.C-0xff0d:    perl:url-picker
#
# I find that url-picker works well in combination with matcher, but you
# can leave out the latter if you don't care for it.  The above enables, in
# addition to the default behavior, the matcher extension and url-picker.
# It directs the key combination of ctrl+enter to call the on_user_command
# function of url-picker.
#
# OPERATION
#
# If a portion of the terminal text has been marked for selection, then the
# search for URLs will be restricted to that region.  Otherwise, the visible
# text of the termainl will be used.
#
# If no URLs are found,  url-picker just pops up an overlay window that
# warns "no URLs found on visible screen" or "no URLs found in visible selected
# text".  The overlay disappears after five seconds, but the terminal is
# immediately operable.
#
# If the region contains only one URL, that URL is launched to the browser.
# The browser is determined by X resources url-picker.launcher if defined,
# otherwise URxvt.urlLauncher.  If neither of these are defined, the
# 'sensible-browser' is used.  The URL will be passed as the first argument.
#
# If more than one URL is available in the region, url-picker places numbered
# labels over the first characters of each URL on the screen.  A prompt
# "Follow: " appears at the bottom of the terminal window, at which you
# can type only numbers, backspace, enter, or escape (all other input is
# ignored).
#
# Escape exits this mode and removes all overlay windows, without doing
# anything.
#
# Enter launches the URL associated with the number that has been typed, if
# that number matches one of the URL labels.  Otherwise, nothing happens.
#
# The labels are numbered in ascending order starting with 1 by default.  You
# can cause them to be numbered in reverse order (so that the last link is
# always number 1) by setting the resource "URxvt.url-picker.order" to
# "descending".
#
# When typing numbers, if the number typed so far uniquely identifies a
# URL, that URL is launched immediately.  Otherwise, the labels that do not
# match the numbers typed so far will be hidden.
#
# The backspace key erases the last number typed, if there is one.
#
# When a URL is launched, all overlay windows are removed and the cursor
# position is restored to where it was in the terminal window before
# url-picker was invoked.  The url launched is displayed on the bottom
# row of the terminal window for five seconds.
#
# RESOURCES
#
# The following resources are recognized by url-picker:
#
# URxvt.urlLauncher         Default browser
# URxvt.url-picker.input.backgroundColor   Bg color for numbers typed
# URxvt.url-picker.input.foregroundColor   Fg color for numbers typed
# URxvt.url-picker.label.backgroundColor   Bg color for numbered labels
# URxvt.url-picker.label.foregroundColor   Fg color for numbered labels
# URxvt.url-picker.launcher    Browser override
# URXVT.url-picker.order       "descending" numbers in reverse
# URxvt.url-picker.prompt.backgroundColor  Bg color for "Follow:" prompt
# URxvt.url-picker.prompt.foregroundColor  Fg color for "Follow:" prompt
# URxvt.url-picker.status.backgroundColor  Bg color for status messages
# URxvt.url-picker.status.foregroundColor  Fg color for status messages
#
# Colors must be specified using urxvt color indices as described in
# the urxvt(1) man page under COLORS AND GRAPHICS.
#
# }}}

my $url =
   qr{
      (?:https?://|ftp://|news://|mailto:|file://|\bwww\.)
      [a-zA-Z0-9\-\@;\/?:&=%\$_.+!*\x27,~#]*
      (
         # Allow a pair of matched parentheses
         \([a-zA-Z0-9\-\@;\/?:&=%\$_.+!*\x27,~#]*\)|
         # exclude some trailing characters (heuristic)
         [a-zA-Z0-9\-\@;\/?:&=%\$_+*~]
      )+
   }x;

sub on_user_command {
  my ($self, $cmd) = @_;
  if ($cmd =~ s/^url-picker\b//) {
    my $labels = {};
    my $hrefs = {};
    my $rowmap = {};
    my $num = 0;
    my $row = 0;
    my $base_col = 0;
    my $text = '';
    my $label_rend = $self->get_rend("label", urxvt::OVERLAY_RSTYLE);
    my $label_urls = sub {
                       my @overlays;
                       while ($text =~ /$url/g) {
                         my $ndx = $-[0];
                         my $href = $&;
                         my $col = 0;
                         for my $key (keys %$rowmap) {
                           my $value = $rowmap->{$key};
                           my ($start, $end) = @$value;
                           if (($start <= $ndx) && ($end >= $ndx)) {
                             $row = $key;
                             $col = $ndx - $start;
                             last;
                           }
                         }
                         my @ov = ($col, $row, $href);
                         push(@overlays, \@ov) if ($row >= 0);
                       }
                       @overlays = reverse @overlays if ($self->{descending});
                       for my $ov (@overlays) {
                         my ($col, $row, $href) = @$ov;
                         $num++;
                         my $overlay = $self->overlay(
                           $col, $row, $self->strwidth($num), 1, $label_rend, 0
                         );
                         $overlay->set(0,0,$num);
                         $labels->{$num} = $overlay;
                         $hrefs->{$num} = $href;
                       }
                     };
    my ($brow, $bcol) = $self->selection_beg();
    my ($erow, $ecol) = $self->selection_end();
    my $issel = ($ecol > $bcol) || ($erow > $brow);
    if ($issel) {         # restrict to selection if one exists
      ($row, $base_col) = ($brow - $self->view_start, $bcol);
      for (split(/\n/, $self->selection())) {
        my $start = length($text) - $base_col;
        $text .= $_;
        $rowmap->{$row} = [$start, (length($text)-1)];
        $base_col = 0;
        $row++;
      }
    } else {            # no selection, use visible terminal
      for (0..($self->nrow - 1)) {
        $row = $_;
        my $start = length($text);
        $text .= $self->ROW_t($row + $self->view_start);
        $rowmap->{$row} = [$start, (length($text)-1)];
      }
    }
    $label_urls->();

    if ($num < 1) {
      my $desc = $issel ? "in visible selected text" : "on visible screen";
      $self->status_msg("url-picker: no URLs found $desc");
    } else {
      my $url_picker = {};
      $url_picker->{prompt} = $self->overlay(
        0, -1, 8, 1, $self->get_rend("prompt", urxvt::OVERLAY_RSTYLE), 0
      );
      $url_picker->{prompt}->set(0,0,"Follow:");
      $url_picker->{labels} = $labels;
      $url_picker->{hrefs} = $hrefs;
      $url_picker->{num} = $num;
      $url_picker->{buffer} = '';
      my ($crow,$ccol) = $self->screen_cur;
      $url_picker->{crow} = $crow;
      $url_picker->{ccol} = $ccol;
      $self->{url_picker} = $url_picker;
      $self->update($url_picker);
    }
  }
  ()
}

sub on_key_press {
  my ($self, $event, $keysym) = @_;
  my $p = $self->{url_picker};
  if ($p) {
    if ($keysym == 0xff1b) {           # escape
      $self->screen_cur($p->{crow},$p->{ccol});
      $self->{url_picker} = ();
    } elsif ($keysym == 0xff08) {      # backspace
      if (length($p->{buffer}) > 0) {
        $p->{buffer} = substr($p->{buffer},0,-1);
        $self->update($p);
      }
    } elsif (($keysym >= 48) && ($keysym <= 57)) {
      $p->{buffer} = $p->{buffer} . ($keysym - 48);
      $self->update($p);
    } elsif ($keysym == 0xff0d) {      # CR
      my $num = $p->{buffer};
      my $hrefs = $p->{hrefs};
      if (($num > 0) && ($num <= $p->{num})) {
        my $href = $hrefs->{$num};
        $self->launch($href);
      }
    }
    return 1;
  }
  ()
}

sub update {
  my ($self, $p) = @_;
  $p->{typing} = $self->overlay(
    8, -1, length($p->{buffer}), 1, $self->get_rend("input", urxvt::DEFAULT_RSTYLE), 0
  );
  $p->{typing}->set(0,0,$p->{buffer});
  my $ndx = 0;
  my $labels = $p->{labels};
  my $hrefs = $p->{hrefs};
  my $len = length($p->{buffer});
  my $size = $p->{num};
  my @matches;
  while (++$ndx <= $size) {
    my $overlay = $labels->{$ndx};
    if (($len == 0) ||
        (($len <= length($ndx)) && (substr($ndx,0,$len) eq $p->{buffer}))) {
      $overlay->show;
      unshift @matches,$hrefs->{$ndx};
    } else {
      $overlay->hide;
    }
  }
  if (scalar(@matches) == 1) {
    $self->launch(@matches[0]);
  } else {
    $self->screen_cur($self->nrow,8+$len);
  }
}

sub launch {
  my ($self, $href) = @_;
  my $p = $self->{url_picker};
  $self->screen_cur($p->{crow},$p->{ccol});
  $self->{url_picker} = ();
  my $launcher = $self->{launcher};
  $self->status_msg($href);
  $self->exec_async ($launcher,$href);
}

sub status_msg {
  my ($self, $msg) = @_;
  $self->{url_picker_msg} = $self->overlay(0,-1,length($msg),1,$self->get_rend("status",urxvt::OVERLAY_RSTYLE),0);
  $self->{url_picker_msg}->set(0,0,$msg);
  $self->{url_picker_timer} = urxvt::timer
                            ->new
                            ->after (5)
                            ->cb (sub {
                                     $self->{url_picker_msg} = ();
                                     $self->{url_pickertimer} = ();
                                   });
}

sub get_rend {
  my ($self, $name, $default) = @_;
  urxvt::SET_COLOR $default,
    $self->my_resource("$name.foregroundColor") || urxvt::GET_BASEFG $default,
    $self->my_resource("$name.backgroundColor") || urxvt::GET_BASEBG $default;
}

sub on_key_release {
  my ($self, $event, $keysym) = @_;
  $self->{url_picker};
}

sub my_resource {
  my ($self, $name) = @_;
  $self->x_resource ("$self->{name}.$name");
}

sub on_start {
  my ($self) = @_;

  ($self->{name} = __PACKAGE__) =~ s/.*:://;
  $self->{name} =~ tr/_/-/;
  $self->{launcher} = $self->my_resource("launcher") ||
                      $self->x_resource("urlLauncher") ||
                      "sensible-browser";
  $self->{descending} = ($self->my_resource("order") eq "descending");
  $self->{url_picker} = ();
}

# vim:set sw=3 sts=3 et:
